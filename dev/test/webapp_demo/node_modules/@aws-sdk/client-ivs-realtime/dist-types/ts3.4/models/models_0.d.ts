import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { IVSRealTimeServiceException as __BaseException } from "./IVSRealTimeServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface Video {
  width?: number;
  height?: number;
  framerate?: number;
  bitrate?: number;
}
export interface CreateEncoderConfigurationRequest {
  name?: string;
  video?: Video;
  tags?: Record<string, string>;
}
export interface EncoderConfiguration {
  arn: string | undefined;
  name?: string;
  video?: Video;
  tags?: Record<string, string>;
}
export interface CreateEncoderConfigurationResponse {
  encoderConfiguration?: EncoderConfiguration;
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export declare class PendingVerification extends __BaseException {
  readonly name: "PendingVerification";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<PendingVerification, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  exceptionMessage?: string;
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export declare const ParticipantTokenCapability: {
  readonly PUBLISH: "PUBLISH";
  readonly SUBSCRIBE: "SUBSCRIBE";
};
export type ParticipantTokenCapability =
  (typeof ParticipantTokenCapability)[keyof typeof ParticipantTokenCapability];
export interface CreateParticipantTokenRequest {
  stageArn: string | undefined;
  duration?: number;
  userId?: string;
  attributes?: Record<string, string>;
  capabilities?: ParticipantTokenCapability[];
}
export interface ParticipantToken {
  participantId?: string;
  token?: string;
  userId?: string;
  attributes?: Record<string, string>;
  duration?: number;
  capabilities?: ParticipantTokenCapability[];
  expirationTime?: Date;
}
export interface CreateParticipantTokenResponse {
  participantToken?: ParticipantToken;
}
export interface ParticipantTokenConfiguration {
  duration?: number;
  userId?: string;
  attributes?: Record<string, string>;
  capabilities?: ParticipantTokenCapability[];
}
export interface CreateStageRequest {
  name?: string;
  participantTokenConfigurations?: ParticipantTokenConfiguration[];
  tags?: Record<string, string>;
}
export interface Stage {
  arn: string | undefined;
  name?: string;
  activeSessionId?: string;
  tags?: Record<string, string>;
}
export interface CreateStageResponse {
  stage?: Stage;
  participantTokens?: ParticipantToken[];
}
export interface S3StorageConfiguration {
  bucketName: string | undefined;
}
export interface CreateStorageConfigurationRequest {
  name?: string;
  s3: S3StorageConfiguration | undefined;
  tags?: Record<string, string>;
}
export interface StorageConfiguration {
  arn: string | undefined;
  name?: string;
  s3?: S3StorageConfiguration;
  tags?: Record<string, string>;
}
export interface CreateStorageConfigurationResponse {
  storageConfiguration?: StorageConfiguration;
}
export interface DeleteEncoderConfigurationRequest {
  arn: string | undefined;
}
export interface DeleteEncoderConfigurationResponse {}
export interface DeleteStageRequest {
  arn: string | undefined;
}
export interface DeleteStageResponse {}
export interface DeleteStorageConfigurationRequest {
  arn: string | undefined;
}
export interface DeleteStorageConfigurationResponse {}
export interface DisconnectParticipantRequest {
  stageArn: string | undefined;
  participantId: string | undefined;
  reason?: string;
}
export interface DisconnectParticipantResponse {}
export interface GetCompositionRequest {
  arn: string | undefined;
}
export interface ChannelDestinationConfiguration {
  channelArn: string | undefined;
  encoderConfigurationArn?: string;
}
export declare const RecordingConfigurationFormat: {
  readonly HLS: "HLS";
};
export type RecordingConfigurationFormat =
  (typeof RecordingConfigurationFormat)[keyof typeof RecordingConfigurationFormat];
export interface RecordingConfiguration {
  format?: RecordingConfigurationFormat;
}
export interface S3DestinationConfiguration {
  storageConfigurationArn: string | undefined;
  encoderConfigurationArns: string[] | undefined;
  recordingConfiguration?: RecordingConfiguration;
}
export interface DestinationConfiguration {
  name?: string;
  channel?: ChannelDestinationConfiguration;
  s3?: S3DestinationConfiguration;
}
export interface S3Detail {
  recordingPrefix: string | undefined;
}
export interface DestinationDetail {
  s3?: S3Detail;
}
export declare const DestinationState: {
  readonly ACTIVE: "ACTIVE";
  readonly FAILED: "FAILED";
  readonly RECONNECTING: "RECONNECTING";
  readonly STARTING: "STARTING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
};
export type DestinationState =
  (typeof DestinationState)[keyof typeof DestinationState];
export interface Destination {
  id: string | undefined;
  state: DestinationState | undefined;
  startTime?: Date;
  endTime?: Date;
  configuration: DestinationConfiguration | undefined;
  detail?: DestinationDetail;
}
export interface GridConfiguration {
  featuredParticipantAttribute?: string;
}
export interface LayoutConfiguration {
  grid?: GridConfiguration;
}
export declare const CompositionState: {
  readonly ACTIVE: "ACTIVE";
  readonly FAILED: "FAILED";
  readonly STARTING: "STARTING";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
};
export type CompositionState =
  (typeof CompositionState)[keyof typeof CompositionState];
export interface Composition {
  arn: string | undefined;
  stageArn: string | undefined;
  state: CompositionState | undefined;
  layout: LayoutConfiguration | undefined;
  destinations: Destination[] | undefined;
  tags?: Record<string, string>;
  startTime?: Date;
  endTime?: Date;
}
export interface GetCompositionResponse {
  composition?: Composition;
}
export interface GetEncoderConfigurationRequest {
  arn: string | undefined;
}
export interface GetEncoderConfigurationResponse {
  encoderConfiguration?: EncoderConfiguration;
}
export interface GetParticipantRequest {
  stageArn: string | undefined;
  sessionId: string | undefined;
  participantId: string | undefined;
}
export declare const ParticipantState: {
  readonly CONNECTED: "CONNECTED";
  readonly DISCONNECTED: "DISCONNECTED";
};
export type ParticipantState =
  (typeof ParticipantState)[keyof typeof ParticipantState];
export interface Participant {
  participantId?: string;
  userId?: string;
  state?: ParticipantState;
  firstJoinTime?: Date;
  attributes?: Record<string, string>;
  published?: boolean;
  ispName?: string;
  osName?: string;
  osVersion?: string;
  browserName?: string;
  browserVersion?: string;
  sdkVersion?: string;
}
export interface GetParticipantResponse {
  participant?: Participant;
}
export interface GetStageRequest {
  arn: string | undefined;
}
export interface GetStageResponse {
  stage?: Stage;
}
export interface GetStageSessionRequest {
  stageArn: string | undefined;
  sessionId: string | undefined;
}
export interface StageSession {
  sessionId?: string;
  startTime?: Date;
  endTime?: Date;
}
export interface GetStageSessionResponse {
  stageSession?: StageSession;
}
export interface GetStorageConfigurationRequest {
  arn: string | undefined;
}
export interface GetStorageConfigurationResponse {
  storageConfiguration?: StorageConfiguration;
}
export interface ListCompositionsRequest {
  filterByStageArn?: string;
  filterByEncoderConfigurationArn?: string;
  nextToken?: string;
  maxResults?: number;
}
export interface DestinationSummary {
  id: string | undefined;
  state: DestinationState | undefined;
  startTime?: Date;
  endTime?: Date;
}
export interface CompositionSummary {
  arn: string | undefined;
  stageArn: string | undefined;
  destinations: DestinationSummary[] | undefined;
  state: CompositionState | undefined;
  tags?: Record<string, string>;
  startTime?: Date;
  endTime?: Date;
}
export interface ListCompositionsResponse {
  compositions: CompositionSummary[] | undefined;
  nextToken?: string;
}
export interface ListEncoderConfigurationsRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface EncoderConfigurationSummary {
  arn: string | undefined;
  name?: string;
  tags?: Record<string, string>;
}
export interface ListEncoderConfigurationsResponse {
  encoderConfigurations: EncoderConfigurationSummary[] | undefined;
  nextToken?: string;
}
export interface ListParticipantEventsRequest {
  stageArn: string | undefined;
  sessionId: string | undefined;
  participantId: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export declare const EventErrorCode: {
  readonly INSUFFICIENT_CAPABILITIES: "INSUFFICIENT_CAPABILITIES";
  readonly PUBLISHER_NOT_FOUND: "PUBLISHER_NOT_FOUND";
  readonly QUOTA_EXCEEDED: "QUOTA_EXCEEDED";
};
export type EventErrorCode =
  (typeof EventErrorCode)[keyof typeof EventErrorCode];
export declare const EventName: {
  readonly JOINED: "JOINED";
  readonly JOIN_ERROR: "JOIN_ERROR";
  readonly LEFT: "LEFT";
  readonly PUBLISH_ERROR: "PUBLISH_ERROR";
  readonly PUBLISH_STARTED: "PUBLISH_STARTED";
  readonly PUBLISH_STOPPED: "PUBLISH_STOPPED";
  readonly SUBSCRIBE_ERROR: "SUBSCRIBE_ERROR";
  readonly SUBSCRIBE_STARTED: "SUBSCRIBE_STARTED";
  readonly SUBSCRIBE_STOPPED: "SUBSCRIBE_STOPPED";
};
export type EventName = (typeof EventName)[keyof typeof EventName];
export interface Event {
  name?: EventName;
  participantId?: string;
  eventTime?: Date;
  remoteParticipantId?: string;
  errorCode?: EventErrorCode;
}
export interface ListParticipantEventsResponse {
  events: Event[] | undefined;
  nextToken?: string;
}
export interface ListParticipantsRequest {
  stageArn: string | undefined;
  sessionId: string | undefined;
  filterByUserId?: string;
  filterByPublished?: boolean;
  filterByState?: ParticipantState;
  nextToken?: string;
  maxResults?: number;
}
export interface ParticipantSummary {
  participantId?: string;
  userId?: string;
  state?: ParticipantState;
  firstJoinTime?: Date;
  published?: boolean;
}
export interface ListParticipantsResponse {
  participants: ParticipantSummary[] | undefined;
  nextToken?: string;
}
export interface ListStagesRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface StageSummary {
  arn: string | undefined;
  name?: string;
  activeSessionId?: string;
  tags?: Record<string, string>;
}
export interface ListStagesResponse {
  stages: StageSummary[] | undefined;
  nextToken?: string;
}
export interface ListStageSessionsRequest {
  stageArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface StageSessionSummary {
  sessionId?: string;
  startTime?: Date;
  endTime?: Date;
}
export interface ListStageSessionsResponse {
  stageSessions: StageSessionSummary[] | undefined;
  nextToken?: string;
}
export interface ListStorageConfigurationsRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface StorageConfigurationSummary {
  arn: string | undefined;
  name?: string;
  s3?: S3StorageConfiguration;
  tags?: Record<string, string>;
}
export interface ListStorageConfigurationsResponse {
  storageConfigurations: StorageConfigurationSummary[] | undefined;
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags: Record<string, string> | undefined;
}
export interface StartCompositionRequest {
  stageArn: string | undefined;
  idempotencyToken?: string;
  layout?: LayoutConfiguration;
  destinations: DestinationConfiguration[] | undefined;
  tags?: Record<string, string>;
}
export interface StartCompositionResponse {
  composition?: Composition;
}
export interface StopCompositionRequest {
  arn: string | undefined;
}
export interface StopCompositionResponse {}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface UpdateStageRequest {
  arn: string | undefined;
  name?: string;
}
export interface UpdateStageResponse {
  stage?: Stage;
}
export declare const ParticipantTokenFilterSensitiveLog: (
  obj: ParticipantToken
) => any;
export declare const CreateParticipantTokenResponseFilterSensitiveLog: (
  obj: CreateParticipantTokenResponse
) => any;
export declare const CreateStageResponseFilterSensitiveLog: (
  obj: CreateStageResponse
) => any;
